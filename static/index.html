<html>

<head>
    <title>Votrl Remote Ctrl</title>
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
    <style>
        #myScroll {
            background-size: cover;
        }

        #myElement {
            width: 100%;
            height: 100%;
            color: white;
        }

        #controlPanel {
            position: absolute;
            left: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 40);
            padding: 8px 10px;
        }

        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <div id="myScroll">
        <div id="myElement">
        </div>
    </div>

    <script src="/hammer.min.js"></script>
    <script src="/socket.io.min.js"></script>
    <script>
        var myElement = document.getElementById('myElement')
        var myScroll = document.getElementById('myScroll')
        // 控制大小
        var sizeRatio = 1280 / 720
        var screenSize = [1280, 720]
        var elementSize = [1280, 720]
        let im = new Image()
        let { clientWidth, clientHeight } = myElement

        let imgBinary = ""

        // 保持元素的长宽比和屏幕一致
        function setElementSize() {
            let windowSize = [document.body.offsetWidth, document.body.offsetHeight]
            if (windowSize[0] / windowSize[1] < sizeRatio) {
                clientWidth = windowSize[0]
                clientHeight = windowSize[0] / sizeRatio
            }
            else {
                clientHeight = windowSize[1]
                clientWidth = windowSize[1] * sizeRatio
            }
            myScroll.style.width = clientWidth
            myScroll.style.height = clientHeight
            elementSize = [clientWidth, clientHeight]
        }

        window.addEventListener("resize", () => {
            setElementSize()
        })


        const socket = io({
            'transports': ['websocket'],
            allowUpgrades: false,
            query: { clientWidth, clientHeight }
        })

        socket.on('connect', () => {
            console.log('connect to server')
        }).on('disconnect', (reason) => {
            console.log('client disconnect', reason)
            if (reason === "io server disconnect") {
                // the disconnection was initiated by the server, you need to reconnect manually
                socket.connect()
            }
        }).on('connect_error', (err) => {
            console.error('client connect_error', err)
        }).on('screenInfo', (d) => {   // 从被控端获取屏幕长宽
            screenSize = [d.width, d.height]
            sizeRatio = screenSize[0] / screenSize[1]
            setElementSize()
        }).on("screenStream", (d) => {
            imgBinary = ""
            let bytes = new Uint8Array(d)
            let len = bytes.byteLength
            for (let i = 0; i < len; ++i)
                imgBinary += String.fromCharCode(bytes[i])
            let url = "data:image/jpeg;base64," + btoa(imgBinary)
            //console.log(url)
            im.src = url
            im.onload = () => {
                myScroll.style.backgroundImage = "url('" + url + "')"
            }
        })

        var mc = new Hammer.Manager(myElement)

        // 设置点击，按事件
        mc.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL }))
        mc.add(new Hammer.Tap({ event: 'tap' }))
        mc.add(new Hammer.Tap({ event: 'righttap', pointers: 2 }))
        mc.get('righttap').recognizeWith('tap')
        mc.add(new Hammer.Press({}))

        var norm = (xy, wh) => {
            if (xy < 0) {
                return 0
            } else if (xy > wh) {
                return wh
            } else {
                return xy
            }
        }

        const startAt = { x: 0, y: 0 }

        mc.on('panstart', (e) => {
            e.preventDefault()
            startAt.x = e.center.x / elementSize[0]
            startAt.y = e.center.y / elementSize[1]
            socket.emit('panstart', {
                x: startAt.x,
                y: startAt.y,
                p: e.pointerType
            })
        }).on('panmove', (e) => {
            e.preventDefault()
            var { x, y } = e.center
            x = norm(x, clientWidth)
            x = x / elementSize[0]
            y = norm(y, clientHeight)
            y = y / elementSize[1]
            deltaY = e.deltaY / elementSize[1]
            socket.emit('panmove', { x, y, deltaY, p: e.pointerType })
        }).on('panend', (e) => {
            e.preventDefault()
            startAt.x = 0
            startAt.y = 0
            socket.emit('panend', {
                x: e.center.x / elementSize[0],
                y: e.center.y / elementSize[1]
            })
        }).on('tap', (e) => {
            let { x, y } = e.center
            let RealX = x / elementSize[0]
            let RealY = y / elementSize[1]
            console.log(RealX, RealY)
            e.preventDefault()
            socket.emit('tap', {
                x: RealX,
                y: RealY
            })
        }).on('righttap', (e) => {
            let { x, y } = e.center
            let RealX = x / elementSize[0]
            let RealY = y / elementSize[1]
            //console.log(RealX, RealY)
            e.preventDefault()
            console.debug('righttap')
            socket.emit('righttap', {
                x: RealX,
                y: RealY
            })
        }).on('press', (e) => {
            e.preventDefault()
            let { x, y } = e.center
            let RealX = x / elementSize[0]
            let RealY = y / elementSize[1]
            socket.emit('press', {
                x: RealX,
                y: RealY
            })
        }).on('pressup', (e) => {
            e.preventDefault()
            let { x, y } = e.center
            let RealX = x / elementSize[0]
            let RealY = y / elementSize[1]
            socket.emit('pressup', {
                x: RealX,
                y: RealY
            })
        })

        // 设置滑动事件
        var myScroll = document.getElementById('myScroll')
        var mc2 = new Hammer.Manager(myScroll)
        mc2.add(new Hammer.Pinch({ enable: true }))
        mc2.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, pointers: 2, interval: 100 }))

        mc2.on('panleft', (e) => {
            e.preventDefault()
            socket.emit('panleft')
        }).on('panright', (e) => {
            e.preventDefault()
            socket.emit('panright')
        }).on('panup', (e) => {
            e.preventDefault()
            socket.emit('panup')
        }).on('pandown', (e) => {
            e.preventDefault()
            socket.emit('pandown')
        }).on('pinchstart', (e) => {
            e.preventDefault()
            let { x, y } = e.center
            let RealX = x / elementSize[0]
            let RealY = y / elementSize[1]
            socket.emit("pinchstart", {
                x: RealX,
                y: RealY
            })
        }).on('pinchend', (e) => {
            e.preventDefault()
            socket.emit("pinchend")
        })

        // 设置键盘按键

        /*document.addEventListener("keydown", (e) => {
            e.preventDefault()
            socket.emit("keydown", e.key)
        })

        document.addEventListener("keyup", (e) => {
            e.preventDefault()
            socket.emit("keyup", e.key)
        })
        */
    </script>
</body>

</html>